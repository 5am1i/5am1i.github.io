<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我来看看效果"><title>阿里Android开发手册-安全 | Samli</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">阿里Android开发手册-安全</h1><a id="logo" href="/.">Samli</a><p class="description">个人博客分享</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">阿里Android开发手册-安全</h1><div class="post-meta">Apr 28, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="八、-安全"><a href="#八、-安全" class="headerlink" title="八、 安全"></a>八、 安全</h3><h5 id="《阿里Android开发手册》中关于安全部分的说明"><a href="#《阿里Android开发手册》中关于安全部分的说明" class="headerlink" title="《阿里Android开发手册》中关于安全部分的说明"></a>《阿里Android开发手册》中关于安全部分的说明</h5><hr>
<ol>
<li><strong>【强制】</strong> 禁止使用常量初始化矢量参数构建 IvParameterSpec，建议 IV 通过随机方<br>式产生。</li>
</ol>
<p><strong>说明：</strong></p>
<p>使用常量初始化向量，密码文本的可预测性会高得多，容易受到字典式攻击。 iv 的<br>作用主要是用于产生密文的第一个 block，以使最终生成的密文产生差异（明文相同<br>的情况下），使密码攻击变得更为困难。</p>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rand = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">SecureRandom r = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">r.nextBytes(rand);</span><br><span class="line">IvParameterSpec iv = <span class="keyword">new</span> IvParameterSpec(rand);</span><br></pre></td></tr></table></figure>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IvParameterSpec iv_ = <span class="keyword">new</span> IvParameterSpec(<span class="string">"1234567890"</span>.getBytes());</span><br><span class="line">System.out.println(iv.getIV());</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>【强制】</strong><br>将 android:allowbackup 属性必须设置为 false，阻止应用数据被导出。</li>
</ol>
<p><strong>说明：</strong></p>
<p>android:allowBackup 原本是 Android 提供的 adb 调试功能，如果设置为 true，<br>可以导出应用数据备份并在任意设备上恢复。这对应用安全性和用户数据隐私构成<br>极大威胁，所以必须设置为 false，防止数据泄露。</p>
<p><strong>正例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:largeHeap</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@drawable/test_launcher"</span>阿里巴巴 <span class="attr">Android</span> 开发手册</span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>【强制】</strong> 如果使用自定义 HostnameVerifier 实现类，必须在 verify()方法中校验服务<br>器主机名的合法性，否则可能受到中间人攻击。</li>
</ol>
<p><strong>说明：</strong></p>
<p>在与服务器建立 https 连接时，如果 URL 的主机名和服务器的主机名不匹配，则<br>可通过该回调接口来判断是否应该允许建立连接。如果回调内实现不恰当，没有有<br>效校验主机名，甚至默认接受所有主机名，会大大增加安全风险。</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不做校验，接受任意域名服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">HttpsURLConnection.setDefaultHostnameVerifier(hnv);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>【强制】</strong> 如果使用自定义 X509TrustManager 实现类，必须在 checkServerTrusted()<br>方法中校验服务端证书的合法性，否则可能受到中间人攻击。</li>
</ol>
<p><strong>说明：</strong></p>
<p>常见误区是 checkServerTrusted()方法根本没有实现，这将导致 X509TrustManager<br>形 同 虚 设 。 该 方 法 中 需 要 实 现 完 备 的 校 验 逻 辑 ， 对 于 证 书 错 误 抛 出<br>CertificateException 。</p>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"yourhostname"</span>.equals(hostname))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">        <span class="keyword">return</span> hv.verify(hostname, session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">    <span class="comment">//do nothing，接受任意客户端证书</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing，接受任意服务端证书</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> X509Certificate[]         getAcceptedIssuers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[] &#123; tm &#125;, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>【强制】</strong> 在 SDK 支持的情况下，Android 应用必须使用 V2 签名，这将对 APK 文<br>件的修改做更多的保护。</p>
</li>
<li><p><strong>【强制】</strong> 所有的 Android 基本组件（Activity、 Service、 BroadcastReceiver、阿里巴巴 Android 开发手册<br>ContentProvider 等）都不应在没有严格权限控制的情况下，将 android:exported 设<br>置为 true。</p>
</li>
<li><p><strong>【强制】</strong> WebView 应设置 WebView#getSettings()#setAllowFileAccess(false)、<br>WebView#getSettings()#setAllowFileAccessFromFileURLs(false) 、<br>WebView#getSettings()#setAllowUniversalAccessFromFileURLs(false)，阻止 file<br>scheme URL 的访问。</p>
</li>
<li><p><strong>【强制】</strong> 不要把敏感信息打印到 log 中。</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>在开发过程中，为了方便调试，通常会使用 log 函数输出一些关键流程的信息，这些信息中通常会包含敏感内容，让攻击者更加容易了解 APP 内部结构，方便破解和攻击，甚至直接获取到有价值的敏感信息。</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="string">"log_leak"</span>;</span><br><span class="line">String password = <span class="string">"log_leak_pwd"</span>;</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>, <span class="string">"usesname"</span> + username);</span><br><span class="line">Log.v(<span class="string">"MY_APP"</span>, <span class="string">"send message to server "</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码使用 Log.d Log.v 打印程序的执行过程的 username 等调试信息，日志没有关闭，攻击者可以直接从 Logcat 中读取这些敏感信息。所以在产品的线上版本中关闭调试接口，不要输出敏感信息。</p>
<ol>
<li><p><strong>【强制】</strong> 确保应用发布版本的 android:debuggable 属性设置为 false。</p>
</li>
<li><p><strong>【强制】</strong> 本地加密秘钥不能硬编码在代码中，更不能使用 SharedPreferences 等本地持久化机制存储。应选择 Android 自身的秘钥库（KeyStore）机制或者其他安全<br>性更高的安全解决方案保存。</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>应用程序在加解密时，使用硬编码在程序中的密钥，攻击者通过反编译拿到密钥可<br>以轻易解密 APP 通信数据。</p>
<ol>
<li><p><strong>【 建议</strong>】 addJavascriptInterface() 可以添加 JS 对本地 Java 方法的调用，但这本身<br>会导致恶意代码的攻击。在 Android 4.2（API Level 17）以下，不应再使用这样的<br>调用方式。在 Android 4.2 及以上，需要对本地被远程调用的方法显式添加<br>@JavascriptInterface annotation。</p>
</li>
<li><p><strong>【强制】</strong> 使用 Android 的 AES/DES/DESede 加密算法时，不要使用 ECB 加密模式，<br>应使用 CBC 或 CFB 加密模式。</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>加密模式有 ECB、 CBC、 CFB、 OFB 等，其中 ECB 的安全性较弱，如果使用固定的密钥，相同的明文将会生成相同的密文，容易受到字典攻击，建议使用 CBC、CFB 或 OFB 等模式。<br>1) ECB：Electronic codebook，电子密码本模式<br>2) CBC：Cipher-block chaining，密码分组链接模式<br>3) CFB：Cipher feedback，密文反馈模式<br>4) OFB：Output feedback，输出反馈模式</p>
<ol>
<li><strong>【强制】</strong> Android APP 在 HTTPS 通信中，验证策略需要改成严格模式。<br>说明：<br>Android APP 在 HTTPS 通信中，使用 ALLOW_ALL_HOSTNAME_VERIFIER，表<br>示允许和所有的 HOST 建立 SSL 通信，这会存在中间人攻击的风险，最终导致敏感<br>信息可能会被劫持，以及其他形式的攻击。</li>
</ol>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLSocketFactory sf = <span class="keyword">new</span> MySSLSocketFactory(trustStore);</span><br><span class="line">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br></pre></td></tr></table></figure>
<p>ALLOW_ALL_HOSTNAME_VERIFIER 关闭 host 验证，允许和所有的 host建立SSL通信，BROWSER_COMPATIBLE_HOSTNAME_VERIFIER 和浏览器兼容的验证策略，即通配符能够匹配所有子域名 ，STRICT_HOSTNAME_VERIFIER 严格匹配模式，hostname 必须匹配第一个 CN 或者任何一个 subject-alts，以上例子使用了 ALLOW_ALL_HOSTNAME_VERIFIER，需要改成 STRICT<em>HOSTNAME</em><br>VERIFIER。</p>
<ol>
<li><p><strong>【推荐】</strong> 在 Android 4.2 （API Level 17）及以上，对安全性要求较高的应用可在 Activity<br>中，对 Activity 所关联的 Window 应用 WindowManager.LayoutParams.FLAG_<br>SECURE，防止被截屏、录屏。但要注意的是，一个 Activity 关联的 Window 可<br>能不止一个，如果使用了 Dialog / DialogFragment 等控件弹出对话框，它们本身<br>也会创建一个新的 Window，也一样需要保护。</p>
</li>
<li><p><strong>【推荐】</strong> zip 中不要包含 ../../file 这样的路径，可能被篡改目录结构，造成攻击。</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>当 zip 压缩包中允许存在”../“的字符串，攻击者可以利用多个”../“在解压时改变 zip 文<br>件存放的位置，当文件已经存在是就会进行覆盖，如果覆盖掉的文件是 so、 dex 或<br>者 odex 文件，就有可能造成严重的安全问题。</p>
<p><strong>正例：</strong></p>
<p>对路径进行判断，存在”..”时抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对重要的 Zip 压缩包文件进行数字签名校验，校验通过才进行解压</span></span><br><span class="line">String entryName = entry.getName();</span><br><span class="line"><span class="keyword">if</span> (entryName.contains(<span class="string">".."</span>))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"unsecurity zipfile!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream dest = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ZipInputStream zis = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/Users/yunmogong/Documents/test/test.zip"</span>)));</span><br><span class="line">    ZipEntry entry;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER];</span><br><span class="line">        String entryName = entry.getName();</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(entryName);</span><br><span class="line">        <span class="comment">//System.out.println("Extracting:" + entry);</span></span><br><span class="line">        dest = <span class="keyword">new</span> BufferedOutputStream(fos, BUFFER);</span><br><span class="line">        <span class="keyword">while</span> ((count=zis.read(data,<span class="number">0</span>,BUFFER)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            dest.write(data, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dest.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>【推荐】</strong> MD5 和 SHA-1、SHA-256 等常用算法是 Hash 算法，有一定的安全性，<br>但不能代替加密算法。敏感信息的存储和传输，需要使用专业的加密机制.</li>
</ol>
</div><iframe src="/donate/?AliPayQR=undefined&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a class="pre" href="/2018/04/28/AndroidManifest-xml的安全问题/">AndroidManifest.xml的安全问题</a><a class="next" href="/2018/04/20/SRC怎么玩/">SRC怎么玩</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://5am1i.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/SRC/" style="font-size: 15px;">SRC</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/12/常见问题修复建议/">常见问题修复建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/信息搜集之搜索引擎/">信息搜集之搜索引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/常用端口速查/">常用端口速查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/动态分析-Eclipse调试/">动态分析-Eclipse调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/动态分析-AndroidStudio调试-IDA-我来了/">动态分析-AndroidStudio调试+IDA 我来了</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/AndroidManifest-xml的安全问题/">AndroidManifest.xml的安全问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/阿里Android开发手册-安全/">阿里Android开发手册-安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/SRC怎么玩/">SRC怎么玩</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/Android去广告/">Android去广告</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/Android平台WebView控件存在跨域访问高危漏洞/">Android平台WebView控件存在跨域访问高危漏洞</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://init1.in/" title="这个友联需要用谷歌浏览器打开" target="_blank">这个友联需要用谷歌浏览器打开</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Samli.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>